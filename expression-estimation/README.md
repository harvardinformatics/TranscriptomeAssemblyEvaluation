# Expression Estimation

## Map-to-reference

To generate our truth-set benchmark for RNA abundance estimation we used [RSEM](https://deweylab.github.io/RSEM/). Specifically, we used RSEM to build an index using [bowtie2](http://bowtie-bio.sourceforge.net/bowtie2/index.shtml) as an aligner with the following generic command line:  

    rsem-prepare-reference -p 12 --bowtie --bowtie2 --gtf Mus_musculus.GRCm38.83.gtf Mus_musculus.GRCm38.dna_sm.toplevel.fa rsem_ensembl_indices/Mus_musculus.GRCm38.83

Then, for each sample we used RSEM to estimate RNA abundance from the bowtie2 alignments:

    rsem-calculate-expression --bowtie2 -p 16 --output-genome-bam --time --paired-end R1.fq R2.fq /PATH/TO/RSEM/INDEX/DIR/Mus_musculus.GRCm38.83 OUTFILE_PREFIX

## De novo transcriptomes

For each sample-assembler combination, we did two rounds of expression estimation. First, we did a "naive" estimation where we did not attempt to group contigs by their BLAT hits to annotated *Mus* transcripts

### TRINITY assemblies

We used a perl script provided by the developers to wrap RSEM, that builds the bowtie2 index and generates "gene" and "isoform" level abundance estimates for Trinity components and contigs, respectively:  

    align_and_estimate_abundance.pl --prep_reference --thread_count 16 --transcripts Trinity.fasta --seqType fq --left R1.fq --right R2.fq --est_method RSEM --aln_method bowtie2 --trinity_mode --output_dir OUTDIR --output_prefix PREFIX


For dUTP and ligation stranded libraries, we supplied the --SS_lib_type flag values of RF and FR, respectively. 

We then performed a second round, where we grouped TRINITY contigs into genes according to their top-scoring BLAT hits. In doing this, we did not use align_and_estimate_abundance.pl, as we discovered that the argument in which one supplies it the map table DOES NOT WORK!! It simply returns abundance estimates based upon the TRINITY component groupings. Thus,and, per RSEM's requirements, we generated a table that maps contig ids to gene ids, and build the index as follows:

    rsem-prepare-reference --transcript-to-gene-map MAP_TABLE --bowtie2 -p 8 /PATH/TO/Trinity.fasta /PATH/TO/INDEX/Trinity

We then estimated abundance:

    rsem-calculate-expression  --bowtie2 -p 16 --time --paired-end R1.fq R2.fq PATH/TO/INDEX/ OUTFILE_PREFIX

For dUTP and ligation stranded libraries, we supplied the --forward-prob flag values of 0 and 1, respectively.

### SHANNON and BINPACKER assemlbies

Both naive and annotation-grouped rounds of abundance estimation were performed by calling RSEM directly, as described above. Neither method groups contigs into putative gene clusters, so naive estimation produces only contig-level expression estimates (although RSEM does produce isoforms.results and genes.results files, with the latter only referencing one isoform).

### Comparison of map-to-reference and map-to-Transcriptome assembly estimates

For transcript-level analyses, we generate a table with the following fields:  

* EnsTsId, the Ensembl transcript id
* BestHitId, the Ensembl transcript's best-hitting contig
* EnsExpCount, the expected count for the reference transcript
* EnsTPM, transcripts-per-million for the reference transcript
* EnsEffLen, the effective length of the Ensembl transcript as estimated by RSEM
* BestExpCount, the expected count of the best-hit contig
* BestTPM, TPM for the best-hit contig
* BestEffLen, the effective length of the best-hit contig

We generate this table with [TranscriptLevel_BuildBlatBestHitReferenceIsoformExpressionTable.py](https://github.com/harvardinformatics/TranscriptomeAssemblyEvaluation/blob/master/expression-estimation/TranscriptLevel_BuildBlatBestHitReferenceIsoformExpressionTable.py) which takes as arguments:

* the \*besthit_coverage.csv file generated via the pipeline described in [coverage](https://github.com/harvardinformatics/TranscriptomeAssemblyEvaluation/tree/master/coverage), via -bmap
* the isoform-level results file generated by RSEM for reference transcripts, via -refex
* the contig-level RSEM results, via -denovex
* the name of the output table, via -o

We subsequently sought to compare the best-hit contig to the reference gene expression level, so added it to the table produced above with [TranscriptLevel_AppendEnsGeneExpressionToBestHitExpressionTable.py](https://github.com/harvardinformatics/TranscriptomeAssemblyEvaluation/blob/master/expression-estimation/TranscriptLevel_AppendEnsGeneExpressionToBestHitExpressionTable.py), which takes as arguments:  

* the gene-transcript map table that links Ensembl gene and transcript ids, via -m
* the table produced by TranscriptLevel_BuildBlatBestHitReferenceIsoformExpressionTable.py, via -e
* the RSEM gene-level output for Ensembl genes, via -gex

We then compare gene-level expression estimates on the reference annotation to those obtained by estimating gene-level expression by grouping assembly contigs by annotation. We do this with [BuildExpressionTableFromGeneLevelAssemblyAndReferenceRsemFiles.py](https://github.com/harvardinformatics/TranscriptomeAssemblyEvaluation/blob/master/expression-estimation/BuildExpressionTableFromGeneLevelAssemblyAndReferenceRsemFiles.py), which produces a table with the following fields:  

* geneid, the ensembl gene id
* ref_len, the combined length of the reference gene intervals
* ref_efflen, the effective length of the reference gene
* ref_expcount, the expected count for the reference gene
* refTPM, TPM for the reference gene
* refFPKM, FPKM for the reference gene
* denovo_len, the combined length of the contig intervals
* denovo_efflen, the effective length of the contig intervals
* denovo_expcount, the expected count for combined contigs
* denovo_TPM, TPM for the combined contigs
* denovo_FPKM, FPKM for the comined inervals

Note, all estimates in the table are generated by RSEM. The python script takes as arguments:  

* the gene-level RSEM output table produced by the annotation-grouped assembly contigs, via -asex
* the gene-level RSEM output table produced by mapping to the gene's reference transcripts, via -refex
* the name of the output table, via =o

 
